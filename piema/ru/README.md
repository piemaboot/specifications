# Спецификация формата Piema
## Содержание
- [Структура файла](#структура-файла)
	- [Сигнатура](#сигнатура)
	- [Заголовки](#заголовки)
	- [Данные](#данные)
- [Обработка данных](#обработка-данных)
	- [Логи (`logs`)](#логи-logs)
	- [Метаданные](#метаданные)
	- [Группа](#группа)
	- [Сущность (Элемент, запись)](#сущность-элемент-запись)
	- [Кастомная иконка](#кастомная-иконка)

## Структура файла
```js
file.piema {
    signature:   [24 байта],  // Сигнатура файла и версии
    headers:     [N байт  ],  // Заголовки файла (TLV-список)
    data:        [N байт  ]   // Данные базы данных
}
```

Файл формата `piema` делится на 3 блока: сигнатура (`signature`), заголовки (`headers`) и данные (`data`). Каждый из блоков нужен для разных целей.

### Сигнатура
```js
signature {
    filesig:   [12 байт],  // Сигнатура файла, всегда [89 61 76 61 75 6C 74 0D 0A 1A 0A 00]
    version:   [12 байт]   // Сигнатура версии
}
```

Сигнатура состоит из двух частей: сигнатура файла (или же формата) и сигнатура версии. Сигнатура файла всегда имеет значение `89 61 76 61 75 6C 74 0D 0A 1A 0A 00`. Сигнатура версии же имеет разные значения зависимо от версии формата:

Версия   | Сигнатура
-------- | -------------------------------------
**v1.0** | `31 34 39 3A 34 32 30 3C 00 00 00 00`

### Заголовки
```js
headers [
    header {
        id:       [1 байт     ],  // ID заголовка
        length:   [4 байта    ],  // Длина данных заголовка
        data:     [length байт]   // Данные заголовка
    }
]
```

Заголовки `piema` файла - это TLV-список[^1]. Заголовки могут иметь следующие типы (`id`):

ID заголовка | Ожидаемая длина данных | Описание                                   | Обязательно
------------ | ---------------------- | ------------------------------------------ | -----------
`00` (0)     | 0 байт                 | Указывает на конец заголовков              | ✅
`01` (1)     | ?                      | Название базы данных                       | ❌
`02` (2)     | 1 байт                 | Метод сжатия данных                        | ✅
`03` (3)     | 32 байта               | SHA256-хеш данных для проверки целостности | ❌

#### Название базы данных (`01`)
Значение этого заголовка - это `UTF-8` строка.

#### Метод сжатия данных (`02`)
Этот заголовок указывает на то, какой метод сжатия был использован. Его значение - и есть этот самый метод:

Значение заголовка | Метод сжатия
------------------ | ------------
`00` (0)           | Без сжатия
`01` (1)           | GZip

#### SHA256-хеш данных для проверки целостности (`03`)
Этот заголовок нужен для проверки целостности данных в базе данных. Его значение - это SHA256-хеш от всех данных [(блок `data`)](#структура-файла)

### Данные
```js
data {
    random:       [32 байта   ],  // Пвсевдорандомные данные для проверки дешифровки
    encrypted:    [1 байт     ],  // Указывает на то, зашифрованы ли данные
    cipher: {                     // Существует только если encrypted=01
        method:   [1 байт     ],  // Метод шифрования
        uses:     [1 байт     ],  // Что использовалось для шифрования данных
        verify:   [32 байта   ],  // Первые 32 байта дешифрованных данных
        length:   [2 байта    ],  // Длина данных шифровщика
        data:     [length байт]   // Данные шифровщика
    },

    data:         [N байт     ]   // Сами данные
}
```

Первое поле занимает 32 байта и называется `random`. Оно нужно для проверки дешифрованных данных. Если это первый цикл (раз) дешифровки, то оно имеет значение `00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00`.

Далее идёт поле `encrypted`, занимающее 1 байт и указывающие на то, зашифрованы ли далее идущие данные.
Если это поле равно `00`, то данные не зашифрованы и можно переходить к [**их обработке.**](#обработка-данных)
Если же его значение равно `01`, то после идут данные шифровщика, с помощью которых нужно дешифровать их.

Следующее поле - `cipher`, как было сказано ранее, указывает на то, как надо дешифровать данные. Его первый байт (`method`) указывает на используемый метод:

Значение `method` | Описание                  | Рекомендуется
----------------- | ------------------------- | -------------
`01` (1)          | `AES-256-CBC`             | ✅

Следующий байт (`uses`) указывает на то, что было использовано в качестве ключа и может иметь следующие значения:

Значение `uses` | Описание                      | Получение
--------------- | ----------------------------- | ---------------------------
`00` (0)        | Мастер-пароль                 | `sha3_256(master_password)`
`01` (1)        | Ключ-файл                     | `sha3_256(keyfile.value)`
`02` (2)        | Физ. ключ                     | `sha3_256(hardware_key)`
`03` (3)        | 2-й тип USB-ключа stngauth    | `pt_usb_key.value`

После идут 32 байта поля `verify` - это первые 32 байт дешифрованных данных (`random`). Они нужно для проверки правильности вводимых данных.

После идёт 2 байта длины (`length`) - целочисленное `big-endian` число. Это длина далее идущих данных шифровщика (`data`).

После дешифрования мы получаем такой же набор байт, который нужно обработать точно таким же образом.

###### AES-256-CBC
Данные этого метода шифрования занимают 16 байт. Они (данные) - это значение `IV` *(**I**nitialization **V**ector)*.

## Обработка данных
Перед тем, как обработать данные нужно сделать следующее:
1. Откинуть первые 33 байта
2. Разжать данные согласно методу сжатия [(заголовок с `02` ID)](#метод-сжатия-данных-02)

После можно приступать к обработке. Те данные, что у нас остались - это кучка подобных блоков:
```js
block {
    type:    [1 байт],  // Тип блока
    data:    [N байт],  // Данные блока
    logs:    [N байт],  // Записи журнала (логов)
    child:   [N байт]   // Дочерние блоки
}
```

Блоки могут иметь следующие типы (`type`):

Значение поля `type` | Описание                                   | Содержание
-------------------- | ------------------------------------------ | ---------------------------------------------
`00` (0)             | Указывает на конец дочерних блоков/данных  | —
`01` (1)             | Метаданные                                 | *данные (`data`)*, *дочерние блоки (`child`)*
`02` (2)             | Группа                                     | *данные (`data`)*, *дочерние блоки (`child`)*
`03` (3)             | Сущность (Элемент)                         | *данные (`data`)*
`04` (4)             | Кастомная иконка **(только в метаданных)** | *данные (`data`)*

Длина и содержание данных (`data`) зависит от типа блоков. Логи (`logs`) - это кучка элементов описанных ниже. А дочерние блоки (`child`) - это точно такая же кучка блоков.

### Логи (`logs`)
```js
logs [
    log {
        type:     [N байт     ],  // Тип записи журнала
        date:     [8 байт     ],  // Дата создания записи
        length:   [4 байта    ],  // Длина данных записи
        data:     [length байт]   // Данные записи
    }
]
```

Все логи начинаются N байт типа (`type`) - UTF-8 строка, оканчивающаяся на `\x00`. Значение `end` указывает на конец записей журнала.

Далее идёт 8 байт даты и времени (`date`) создания записи журнала. Значение этого поля - это `Timestamp64`. 

После идут 4 байта длины (`length`) данных - целочисленное `big-endian` число. После идут данные записи (`data`) длиною в `length` байт.

### Метаданные
```js
block[metadata] {
    pass_cipher:    [1 байт ],  // Метод шифрования защищённых (скрытых) аттрибутов
    pass_data:      [8 байт ],  // Данные метода шифрования
    generator:      [N байт ],  // Название генератора 
    real_name:      [N байт ],  // Реальное название базы данных
    description:    [N байт ],  // Описание базы данных
    created:        [8 байт ],  // Дата создания базы данных
    modified:       [8 байт ],  // Дата и время последнего изменения базы данных
    logs_enabled:   [1 байт ],  // Включен ли журнал
    logs_climit:    [2 байта],  // Лимит количества записей журнала у 1 элемента; 0 - нет лимита
    logs_slimit:    [8 байт ],  // Лимит размера журнала у 1 элемента; 0 - нет лимита
    recyle_bin:     [16 байт],  // UUID группы корзины, если её нет, то 0
    custom:         [N байт ]   // Пары ключ-значение; Кастомные метаданные
}
```

Тут лучше описать типы и длины в виде таблицы:

Название поля    | Тип           | Длина, байты | Метод хранения              | Описание
---------------- | ------------- | ------------ | --------------------------- | ---------------------------------------------------
**pass_cipher**  | `Enum`        | 1            | Ниже                        | Метод шифрования защищённых (скрытых) аттрибутов
**pass_data**    | `Bytes`       | 8            | Ниже                        | Данные метода шифрования
**generator**    | `String`      |              | UTF-8 строка + `\x00`       | Название генератора базы данных
**real_name**    | `String`      |              | UTF-8 строка + `\x00`       | Реальное название базы данных
**description**  | `String`      |              | UTF-8 строка + `\x00`       | Описание базы данных
**created**      | `Timestamp64` | 8            | Timestamp64                 | Дата создания базы данных
**modified**     | `Timestamp64` | 8            | Timestamp64                 | Дата и время последнего изменения базы данных
**logs_enabled** | `Boolean`     | 1            | `0` - `false`; `1` - `true` | Включен ли журнал
**logs_climit**  | `UInt16`      | 2            | `UInt16`, `big-endian`      | Лимит количества логов у элемента; `0` - нет лимита
**logs_slimit**  | `UInt64`      | 8            | `UInt64`, `big-endian`      | Лимит размера логов у элемента; `0` - нет лимита
**recyle_bin**   | `UUID`        | 16           | UUID                        | UUID группы корзины, если её нет, то `0`
**custom**       | `Dictionary`  |              | Ниже                        | Кастомные метаданные

`pass_cipher` может иметь следующие значение:

Значение поля | Метод          | Значение `pass_data`         | Рекомендуется
------------- | -------------- |----------------------------- | -------------
`00` (0)      | Без шифрования | `00 00 00 00 00 00 00 00`    | ❌
`01` (1)      | ARC4           | `00 00 00 00 00 00 00 00`    | 
`02` (2)      | Salsa20        | `IV` (Initialization Vector) | ✅

В качестве ключа у любого из этих методов шифрования используется тот же ключ, что и для дешифровки данных [(см. выше)](#данные).

###### Хранение кастомных метаданных
```js
custom [
    entry {
        key:     [N байт],  // Ключ
        value:   [N байт]   // Значение
    }
]
```

Кастомные метаданные хранятся как пары ключ-значение. Сначала идёт поле ключ `key`, после поле `value`. Оба поля - это UTF-8 строки, оканчивающиеся на `\x00`. Пара ключ-значение с пустым ключом (не учитывая `\x00`) указывает на конец словаря.

### Группа
```js
block[group] {
    uuid:       [16 байт],  // UUID группы
    name:       [N байт ],  // Название группы
    comment:    [N байт ],  // Комментарий к группе
    icon:       [16 байт],  // UUID иконки группы
    created:    [8 байт ],  // Дата и время создания группы
    modified:   [8 байт ],  // Дата и время изменения группы
    expiry:     [8 байт ],  // Дата и время истечение срока действия группы
    flags:      [8 байт ],  // Флаги группы
    custom:     [N байт ]   // Пары ключ-значение; Кастомная информация о группе
}
```

Тут лучше описать типы и длины в виде таблицы:

Название поля | Тип           | Длина, байты | Метод хранения                         | Описание
------------- | ------------- | ------------ | -------------------------------------- | --------------------------------------------
**uuid**      | `UUID`        | 16           | UUID                                   | UUID группы
**name**      | `String`      |              | UTF-8 строка + `\x00`                  | Название группы
**comment**   | `String`      |              | UTF-8 строка + `\x00`                  | Комментарий (описание) к группе
**icon**      | `UUID`        | 16           | UUID                                   | UUID иконки группы
**created**   | `Timestamp64` | 8            | Timestamp64                            | Дата и время создания группы
**modified**  | `Timestamp64` | 8            | Timestamp64                            | Дата и время изменения группы
**expiry**    | `Timestamp64` | 8            | Timestamp64                            | Дата и время истечение срока действия группы
**flags**     | `UInt64`      | 8            | UInt64                                 | Флаги группы
**custom**    | `Dictionary`  |              | [Выше](#хранение-кастомных-метаданных) | Кастомные метаданные

Значение поля `flags` высчитывается следующим образом:
```py
flags = flag1 | flag2  # flag1 = 1 << 1; flag2 = 1 << 2
```

Существуют следующие флаги:

Название          | Значение флага | Описание
----------------- | -------------- | -----------------------------------------
`expiry`          | `1 << 1`       | У группы ограниченное время существования
`search`          | `1 << 2`       | Включён поиск по этой группе
`inherits_search` | `1 << 3`       | Группа наследует `search`
`templates`       | `1 << 4`       | Эта группа содержит в себе шаблоны

### Сущность (Элемент, запись)
```js
block[entry] {
    uuid:          [16 байт],  // UUID записи
    template:      [16 байт],  // UUID записи-шаблона
    name:          [N байт ],  // Название записи
    comment:       [N байт ],  // Комментарий к записи
    icon:          [16 байт],  // UUID иконки записи
    created:       [8 байт ],  // Дата и время создания записи
    modified:      [8 байт ],  // Дата и время изменения записи
    expiry:        [8 байт ],  // Дата и время истечение срока действия записи
    flags:         [8 байт ],  // Флаги записи
    background:    [4 байта],  // Цвет фона записи
    foreground:    [4 байта],  // Цвет текста записи
    tags:          [N байт ],  // Разделённые запятыми теги записи
    attributes:    [N байт ],  // Аттрибуты записи
    attachments:   [N байт ],  // Вложения записи
    custom:        [N байт ]   // Пары ключ-значение; Кастомная информация о записи
}
```

Тут лучше описать типы и длины в виде таблицы:

Название поля   | Тип           | Длина, байты | Метод хранения                         | Описание
--------------- | ------------- | ------------ | -------------------------------------- | ----------------------------------------------
**uuid**        | `UUID`        | 16           | UUID                                   | UUID записи
**template**    | `UUID`        | 16           | UUID                                   | UUID записи-шаблона
**name**        | `String`      |              | UTF-8 строка + `\x00`                  | Название записи
**comment**     | `String`      |              | UTF-8 строка + `\x00`                  | Комментарий (описание) к записи
**icon**        | `UUID`        | 16           | UUID                                   | UUID иконки записи
**created**     | `Timestamp64` | 8            | Timestamp64                            | Дата и время создания записи
**modified**    | `Timestamp64` | 8            | Timestamp64                            | Дата и время изменения записи
**expiry**      | `Timestamp64` | 8            | Timestamp64                            | Дата и время истечение срока действия записи
**flags**       | `UInt64`      | 8            | UInt64                                 | Флаги записи
**background**  | `RGBA`        | 4            | красный, зелёный, синий, альфа каналы  | Цвет фона записи; `00 00 00 00` - не выбрано
**foreground**  | `RGBA`        | 4            | красный, зелёный, синий, альфа каналы  | Цвет текста записи; `00 00 00 00` - не выбрано
**tags**        | `String`      |              | UTF-8 строка (`tag,tag2,...`) + `\x00` | Разделённые запятыми теги записи
**attributes**  | `List[Attr]`  |              | Ниже                                   | Атрибуты записи
**attachments** | `List[File]`  |              | Ниже                                   | Вложения записи
**custom**      | `Dictionary`  |              | [Выше](#хранение-кастомных-метаданных) | Кастомные метаданные

Значение поля `flags` высчитывается следующим образом:
```py
flags = flag1 | flag2  # flag1 = 1 << 1; flag2 = 1 << 2
```

Существуют следующие флаги:

Название          | Значение флага | Описание
----------------- | -------------- | -------------------------------------------------------------
`expiry`          | `1 << 1`       | У записи ограниченное время существования
`template`        | `1 << 2`       | Эта запись - шаблон, может наследоваться того же флага группы

###### Атрибуты
```js
attributes [
    attribute {
        uuid:        [16 байт],  // UUID аттрибута, наследуется от UUID аттрибута у шаблона
        name:        [N байт ],  // Название аттрибута
        protected:   [1 байт ],  // Защищено (скрыто) ли значение аттрибута
        length:      [2 байта],  // Длина данных (значения) аттрибута
        value:       [N байт ]   // Значение аттрибута
    }
]
```

Первое поле атрибута - это UUID, оно наследуется от UUID того же атрибута у шаблона. Атрибут с UUID `00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00` указывает на конец списка атрибутов. 

Второе поле - это название (`name`) - UTF-8 строка, оканчивающаяся на `\x00`. Пустое значение (не учитывая `\x00`) обозначает, что название нужно наследовать от того же атрибута у шаблона.

Далее идёт логическое (`0` - `false`; `1` - `true`) поле `protected`, указывающие на то, защищены ли данные атрибута. Может иметь значение `02`, тогда значение наследуется от того же атрибута у шаблона.

После идёт поле длины (`length`) - целочисленное `big-endian` число. Оно указывает на длину значение атрибута.

Последнее поле - `value` - имеет длину, указанную в поле `length`. Если значение поля `protected` - это `0` (`00`), то дополнительно дешифровать значение не нужно. Если же оно имеет значение `1` (`01`), то сначала нужно дешифровать его, согласно `pass_cipher` и `pass_data` из метаданных.

###### Вложения
```js
attachments [
	attachment {
		uuid:        [16 байт    ],  // UUID вложения
		name:        [N байт     ],  // Название вложения
		comment:     [N байт     ],  // Комментарий к вложению
		protected:   [1 байт     ],  // Защищено (скрыто) ли вложение
		length:      [8 байт     ],  // Длина данных вложения
		data:        [length байт]   // Данные вложения
	}
]
```

Тут лучше описать типы и длины в виде таблицы:

Название поля   | Тип           | Длина, байты | Метод хранения              | Описание
--------------- | ------------- | ------------ | --------------------------- | -----------------------------
**uuid**        | `UUID`        | 16           | UUID                        | UUID вложения
**name**        | `String`      |              | UTF-8 строка + `\x00`       | Название вложения
**comment**     | `String`      |              | UTF-8 строка + `\x00`       | Комментарий к вложению
**protected**   | `Boolean`     | 1            | `0` - `false`; `1` - `true` | Защищено (скрыто) ли вложение
**length**      | `UInt64`      | 8            | UInt64, `big-endian`        | Длина данных вложения
**data**        | `Bytes`       | **length**   | Содержимое файла иконки     | Данные вложения

Если вложение защищено (`protected` = `1`), то его нужно дешифровать точно так же как и защищённые атрибуты:
> Если значение поля `protected` - это `0` (`00`), то дополнительно дешифровать данные не нужно. Если же оно имеет значение `1` (`01`), то сначала нужно дешифровать их, согласно  `pass_cipher` и `pass_data` из метаданных.

### Кастомная иконка
```js
block[custom_icon] {
    uuid:       [16 байт    ],  // UUID иконки
    name:       [N байт     ],  // Название иконки
    modified:   [8 байт     ],  // Время изменения иконки
    length:     [8 байт     ],  // Длина данных иконки
    data:       [length байт]   // Данные иконки
}
```

Тут лучше описать типы и длины в виде таблицы:

Название поля   | Тип           | Длина, байты | Метод хранения          | Описание
--------------- | ------------- | ------------ | ----------------------- | -----------------------------
**uuid**        | `UUID`        | 16           | UUID                    | UUID иконки
**name**        | `String`      |              | UTF-8 строка + `\x00`   | Название иконки
**modified**    | `Timestamp64` | 8            | Timestamp64             | Дата и время изменения иконки
**length**      | `UInt64`      | 8            | UInt64, `big-endian`    | Длина данных иконки
**data**        | `Bytes`       | **length**   | Содержимое файла иконки | Данные иконки

## Запись данных
Для начала запишем сигнатуру формата:
```
89 61 76 61 75 6C 74 0D 0A 1A 0A 00
```

После записываем сигнатуру версии, текущая версия - **v1.0**, т.е. эту сигнатуру:
```
31 34 39 3A 34 32 30 3C 00 00 00 00
```

После нам нужно записать заголовки:
1. Название базы данных (например, `Test Database`):
	> ```js
	> 01                                      // ID заголовка
	> 00 00 00 0D                             // Длина (13 байт) в UInt32, big-endian
	> 54 65 73 74 20 44 61 74 61 62 61 73 65  // "Test Database" в UTF-8
	> ```
2. Метод сжатия данных (например, `GZip`):
	> ```js
	> 01           // ID заголовка
	> 00 00 00 01  // Длина (13 байт) в UInt32, big-endian
	> 01           // GZip
	> ```
3. В этом примере нет SHA256-хеша
4. И, наконец, указываем на конец блока заголовков:
	> ```js
	> 01  // ID заголовка
	> ```

На данный момент файл должен выглядеть так:
```js
89 61 76 61 75 6C 74 0D 0A 1A 0A 00                    // Сигнатура формата
31 34 39 3A 34 32 30 3C 00 00 00 00                    // Версия формата (v1.0)
01 00 00 00 0D 54 65 73 74 20 44 61 74 61 62 61 73 65  // Название БД: "Test Database"
01 00 00 00 01 01                                      // Метод сжатия: GZip
01                                                     // Конец заголовков
```

А теперь самое сложное, нам нужно сжать и зашифровать некоторые данные. Возьмём что у нас есть следующие данные:
```js
block[metadata] {
    pass_cipher:    Salsa20,
    pass_data:      b"\x63\x7d\xb4\xcb\xf4\x6c\xf3\xb8",
    generator:      "piema example",
    real_name:      "piema example database",
    description:    "какое-то описание",
    created:        2023-10-09T18:40:30,
    modified:       2023-10-09T18:40:30,
    logs_enabled:   true,
    logs_climit:    0,
    logs_slimit:    0,
    recyle_bin:     UUID("e4b0d7ba-a24f-4b9f-b61f-7c6d13c41265"),
    custom:         {
	    hello:      "world!"
    }
}

block[group] {
	uuid:           UUID("e4b0d7ba-a24f-4b9f-b61f-7c6d13c41265"),
    name:           "Корзина",
    comment:        "Группа для удалённых записей",
    icon:           UUID("00000000-0000-0000-0000-000000000002"),  // Стандартная иконка корзины
    created:        2023-10-09T18:40:30,
    modified:       2023-10-09T18:40:30,
    expiry:         1970-01-01T00:00:01,
    flags:          4,
    custom:         {
	    hello:      "world!"
    }
}

block[group] {
	uuid:           UUID("df8ec339-d024-4697-9379-b1ce889996b1"),
    name:           "Основная",
    comment:        "",
    icon:           UUID("00000000-0000-0000-0000-000000000001"),  // Стандартная иконка группы
    created:        2023-10-09T18:40:30,
    modified:       2023-10-09T18:40:30,
    expiry:         1970-01-01T00:00:01,
    flags:          4,
    custom:         {
	    hello:      "world!"
    }
}
```

А мастер-пароль у базы данных - `test1234`. 

[^1]: TLV *(**англ.** **T**ype-**L**ength-**V**alue)* - Тип-Длина-Значение
